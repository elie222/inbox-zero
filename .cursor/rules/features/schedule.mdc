---
description: Schedule feature documentation
globs: 
alwaysApply: false
---
# Schedule Feature - Developer Guide

## What is Schedule?

Schedule is a flexible scheduling system that handles recurring events in the application. It's designed to solve the complex problem of "when should something happen next?" with support for:

- **Custom intervals** - Daily, weekly, monthly, or any number of days
- **Multiple occurrences** - "3 times per week" or "twice daily"
- **Specific days** - "Only on weekdays" or "Mondays and Fridays"
- **Precise timing** - "Every day at 11:00 AM"

**Primary Use Cases:**
- Digest email scheduling (when to send summary emails)
- Recurring notifications and reminders
- Any feature that needs smart, user-configurable scheduling

**Key Benefits:**
- Handles complex scheduling logic in one place
- User-friendly configuration via UI components
- Automatic calculation of next occurrence dates
- Supports both simple and advanced scheduling patterns

---

## How It Works - Scheduling Logic

### Basic Concepts

```mermaid
graph TD
    A[User Sets Schedule] --> B[Calculate Next Date]
    B --> C[Store nextOccurrenceAt]
    C --> D[Event Triggers]
    D --> E[Update lastOccurrenceAt]
    E --> B
```

### Scheduling Patterns

**1. Simple Intervals**
```typescript
// Every 7 days at 11 AM
{
  intervalDays: 7,
  occurrences: 1,
  timeOfDay: "11:00"
}
```

**2. Multiple Occurrences**
```typescript
// 3 times per week (every ~2.33 days)
{
  intervalDays: 7,
  occurrences: 3,
  timeOfDay: "09:00"
}
// Creates evenly spaced slots: Day 1, Day 3.33, Day 5.67
```

**3. Specific Days**
```typescript
// Mondays and Fridays at 2 PM
{
  intervalDays: 7,
  daysOfWeek: 0b0100010, // Binary: Mon=1, Fri=5
  timeOfDay: "14:00"
}
```

### How Multiple Occurrences Work

When `occurrences > 1`, the system divides the interval into equal slots:

```typescript
// 3 times per week example
const intervalDays = 7;
const occurrences = 3;
const slotSize = intervalDays / occurrences; // 2.33 days

// Slots: 0, 2.33, 4.67 days from interval start
// Next occurrence = first slot after current time
```

---

## Implementation Guide

### Setting Up Schedule for a Feature

**Step 1: Add Schedule to your model**
```prisma
model YourFeature {
  id               String        @id
  scheduleId      String?
  schedule        Schedule? @relation(fields: [scheduleId], references: [id])
  // ... other fields
}
```

**Step 2: Calculate next occurrence**
```typescript
import { calculateNextScheduleDate } from '@/utils/schedule';

const nextDate = calculateNextScheduleDate({
  intervalDays: schedule.intervalDays,
  occurrences: schedule.occurrences,
  daysOfWeek: schedule.daysOfWeek,
  timeOfDay: schedule.timeOfDay
});

// Update your model
await prisma.yourFeature.update({
  where: { id },
  data: { nextOccurrenceAt: nextDate }
});
```

**Step 3: Check for due events**
```typescript
// Find items ready to process
const dueItems = await prisma.yourFeature.findMany({
  where: {
    nextOccurrenceAt: {
      lte: new Date() // Due now or in the past
    }
  }
});
```

### Adding Schedule UI to Settings

**Step 1: Use SchedulePicker component**
```typescript
import { SchedulePicker } from '@/components/SchedulePicker';

function YourSettingsComponent() {
  const [schedule, setSchedule] = useState(initialSchedule);
  
  return (
    <SchedulePicker
      value={schedule}
      onChange={setSchedule}
      // Component handles all the complex UI logic
    />
  );
}
```

**Step 2: Map form data to Schedule**
```typescript
import { mapToSchedule } from '@/utils/schedule';

const handleSubmit = async (formData) => {
  const schedule = mapToSchedule(formData);
  
  await updateScheduleAction({
    emailAccountId,
    schedule
  });
};
```

### Working with Days of Week Bitmask

The `daysOfWeek` field uses a bitmask where each bit represents a day:

```typescript
// Bitmask reference (Sunday = 0, Monday = 1, etc.)
const DAYS = {
  SUNDAY: 0b0000001,    // 1
  MONDAY: 0b0000010,    // 2  
  TUESDAY: 0b0000100,   // 4
  WEDNESDAY: 0b0001000, // 8
  THURSDAY: 0b0010000,  // 16
  FRIDAY: 0b0100000,    // 32
  SATURDAY: 0b1000000   // 64
};

// Weekdays only (Mon-Fri)
const weekdays = DAYS.MONDAY | DAYS.TUESDAY | DAYS.WEDNESDAY | 
                 DAYS.THURSDAY | DAYS.FRIDAY; // 62

// Weekends only
const weekends = DAYS.SATURDAY | DAYS.SUNDAY; // 65
```

---

## Core Components & APIs

### Database Schema

```prisma
model Schedule {
  id               String    @id @default(cuid())
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  
  // Scheduling configuration
  intervalDays     Int?      // Interval length (7 = weekly)
  occurrences      Int?      // Times per interval (3 = 3x per week)
  daysOfWeek       Int?      // Bitmask for specific days
  timeOfDay        DateTime? // Time component only
  
  // Tracking
  lastOccurrenceAt DateTime? // When it last happened
  nextOccurrenceAt DateTime? // When it should happen next
  
  // Relationships
  emailAccountId   String
  emailAccount     EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  
  @@unique([emailAccountId])
}
```

### Core Functions

**`calculateNextScheduleDate()`** - Main scheduling function
```typescript
function calculateNextScheduleDate(
  schedule: Pick<Schedule, "intervalDays" | "daysOfWeek" | "timeOfDay" | "occurrences">,
  fromDate: Date = new Date()
): Date
```

**`mapToSchedule()`** - Convert form data to database format
```typescript
function mapToSchedule(formData: ScheduleFormData): Schedule
```

**`getInitialScheduleProps()`** - Convert database to form format
```typescript
function getInitialScheduleProps(schedule?: Schedule): ScheduleFormData
```

### UI Components

**SchedulePicker** - Complete schedule selection UI
```typescript
interface SchedulePickerProps {
  value: ScheduleFormData;
  onChange: (value: ScheduleFormData) => void;
  disabled?: boolean;
}
```

**Supported frequency types:**
- `NEVER` - Disabled
- `DAILY` - Every day
- `WEEKLY` - Once per week
- `MONTHLY` - Once per month  
- `CUSTOM` - User-defined pattern

---

## Advanced Scheduling Examples

### Complex Patterns

**Twice daily (morning and evening)**
```typescript
{
  intervalDays: 1,
  occurrences: 2,
  timeOfDay: "09:00" // Base time, second occurrence ~12 hours later
}
```

**Business days only**
```typescript
{
  intervalDays: 7,
  daysOfWeek: 0b0111110, // Mon-Fri bitmask
  timeOfDay: "10:00"
}
```

**Monthly on specific days**
```typescript
{
  intervalDays: 30,
  daysOfWeek: 0b0000010, // Mondays only
  occurrences: 1,
  timeOfDay: "15:00"
}
```

### Handling Edge Cases

**Timezone considerations:**
```typescript
// Always work with user's local timezone
const userTime = new Date().toLocaleString("en-US", {
  timeZone: user.timezone || "UTC"
});
```

**Leap years and month boundaries:**
```typescript
// The system handles these automatically
// 30-day intervals work across month boundaries
// Leap years are handled by date-fns utilities
```

---

## File Reference

### Core Implementation
- `apps/web/utils/schedule.ts` - Main scheduling logic and utilities
- `apps/web/prisma/schema.prisma` - Schedule model definition

### UI Components
- `apps/web/app/(app)/[emailAccountId]/settings/SchedulePicker.tsx` - Schedule selection UI
- `apps/web/app/(app)/[emailAccountId]/settings/DigestMailScheduleSection.tsx` - Digest-specific settings

### Integration Examples
- `apps/web/utils/actions/settings.ts` - Settings management actions
- `apps/web/app/api/resend/digest/route.ts` - Digest scheduling implementation
- `apps/web/app/api/resend/digest/all/route.ts` - Batch processing with schedule checks

### Validation & Types
- `apps/web/app/api/ai/digest/validation.ts` - API validation schemas
- `apps/web/types/schedule.ts` - TypeScript type definitions
