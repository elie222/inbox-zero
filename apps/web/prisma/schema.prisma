datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Account, User, Session, and VerificationToken based on: https://authjs.dev/reference/adapter/prisma
model Account {
  id                    String        @id @default(cuid())
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  userId                String
  provider              String
  type                  String        @default("oidc") // next-auth deprecated field
  providerAccountId     String
  refresh_token         String?       @db.Text
  refreshTokenExpiresAt DateTime?
  access_token          String?       @db.Text
  expires_at            DateTime?     @default(now())
  token_type            String?
  scope                 String?
  id_token              String?       @db.Text
  session_state         String?
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccount          EmailAccount?

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// not in use. we only use jwt for sessions
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  ipAddress    String?
  userAgent    String?
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  activeOrganizationId String?
  activeOrganization   Organization? @relation(fields: [activeOrganizationId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([activeOrganizationId])
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  name          String?
  email         String    @unique
  emailVerified Boolean?  @default(false)
  image         String?
  accounts      Account[]
  sessions      Session[]

  // additional fields
  completedOnboardingAt    DateTime? // questions about the user. e.g. their role
  completedAppOnboardingAt DateTime? // how to use the app
  onboardingAnswers        Json?
  lastLogin                DateTime?
  utms                     Json?
  errorMessages            Json? // eg. user set incorrect AI API key

  // survey answers (extracted from onboardingAnswers for easier querying)
  surveyFeatures     String[] // multiple choice: features user is interested in
  surveyRole         String? // single choice: user's role. Now using `EmailAccount.role` instead
  surveyGoal         String? // single choice: what user wants to achieve
  surveyCompanySize  Int? // numeric company size: 1 (solo), 5 (2-10), 50 (11-100), 500 (101-1000), 1000 (1000+)
  surveySource       String? // single choice: how user heard about Inbox Zero
  surveyImprovements String? // open text: what user wants to improve

  // settings
  aiProvider    String?
  aiModel       String?
  aiApiKey      String?
  webhookSecret String?

  // referral system
  referralCode String? @unique // User's own referral code

  // premium can be shared among multiple users
  premiumId      String?
  premium        Premium? @relation(name: "userPremium", fields: [premiumId], references: [id])
  // only admin users can manage premium
  premiumAdminId String?
  premiumAdmin   Premium? @relation(fields: [premiumAdminId], references: [id])

  apiKeys ApiKey[]

  emailAccounts EmailAccount[]

  // Referral relationships
  referralsMade    Referral[] @relation("ReferrerUser")
  referralReceived Referral?  @relation("ReferredUser")
}

// Migrating over to the new settings model. Currently most settings are in the User model, but will be moved to this model in the future.
model EmailAccount {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name  String? // Name associated with the Google account
  image String? // Profile image URL from the Google account

  about                     String?
  writingStyle              String?
  signature                 String? // User's email signature from provider or manually set
  includeReferralSignature  Boolean   @default(true)
  watchEmailsExpirationDate DateTime?
  watchEmailsSubscriptionId String? // For Outlook subscription ID
  lastSyncedHistoryId       String?
  behaviorProfile           Json?
  personaAnalysis           Json? // ai analysis of the user's persona
  role                      String? // the role confirmed by the user - previously `User.surveyRole`

  statsEmailFrequency       Frequency         @default(WEEKLY)
  summaryEmailFrequency     Frequency         @default(WEEKLY)
  lastSummaryEmailAt        DateTime?
  coldEmailBlocker          ColdEmailSetting? // @deprecated
  coldEmailDigest           Boolean           @default(false) // @deprecated
  coldEmailPrompt           String? // @deprecated
  rulesPrompt               String? // @deprecated
  autoCategorizeSenders     Boolean           @default(false)
  multiRuleSelectionEnabled Boolean           @default(false)

  digestSchedule Schedule?

  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId String  @unique
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  labels           Label[]
  rules            Rule[]
  executedRules    ExecutedRule[]
  newsletters      Newsletter[]
  coldEmails       ColdEmail[]
  groups           Group[]
  categories       Category[]
  threadTrackers   ThreadTracker[]
  cleanupJobs      CleanupJob[]
  cleanupThreads   CleanupThread[]
  emailMessages    EmailMessage[]
  emailTokens      EmailToken[]
  knowledge        Knowledge[]
  chats            Chat[]
  digests          Digest[]
  scheduledActions ScheduledAction[]

  members             Member[]
  invitations         Invitation[]
  ssoproviders        SsoProvider[]
  calendarConnections CalendarConnection[]
  mcpConnections      McpConnection[]

  @@index([userId])
  @@index([lastSummaryEmailAt])
}

model Organization {
  id          String        @id @default(cuid())
  name        String
  slug        String        @unique
  logo        String?
  metadata    Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  members     Member[]
  SsoProvider SsoProvider[]
  sessions    Session[]
  invitations Invitation[]
}

model Member {
  id             String       @id @default(cuid())
  organizationId String
  emailAccountId String
  role           String       @default("member") // "admin" | "member"
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([organizationId, emailAccountId])
  @@index([emailAccountId])
}

model Invitation {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  inviter        EmailAccount @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([inviterId])
  @@map("invitation")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model SsoProvider {
  id             String        @id @default(cuid())
  issuer         String
  oidcConfig     String?
  samlConfig     String?
  emailAccountId String?
  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  providerId     String        @unique
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  domain         String

  @@index([emailAccountId])
  @@index([organizationId])
  @@map("ssoProvider")
}

model Digest {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  items          DigestItem[]
  sentAt         DateTime?
  status         DigestStatus @default(PENDING)

  @@index([emailAccountId])
}

model DigestItem {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  messageId   String
  threadId    String
  content     String          @db.Text
  digestId    String
  digest      Digest          @relation(fields: [digestId], references: [id], onDelete: Cascade)
  actionId    String?
  action      ExecutedAction? @relation(fields: [actionId], references: [id], onDelete: Cascade)
  coldEmailId String?
  coldEmail   ColdEmail?      @relation(fields: [coldEmailId], references: [id])

  @@unique([digestId, threadId, messageId])
  @@index([actionId])
  @@index([coldEmailId])
}

model Schedule {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intervalDays Int? // Total interval in days
  occurrences  Int? // Number of times within the interval

  // Bit mask for days of week (0b0000000 to 0b1111111)
  // Each bit represents a day (Sunday to Saturday)
  // e.g., 0b1000001 means Sunday and Saturday
  daysOfWeek Int? // 0-127 (2^7 - 1)

  // Time of day stored as DateTime with canonical date (1970-01-01)
  // Only the time portion is used, but DateTime preserves timezone info
  // Example: "1970-01-01T09:30:00Z", "1970-01-01T14:15:00Z"
  timeOfDay DateTime?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  lastOccurrenceAt DateTime?
  nextOccurrenceAt DateTime?

  @@unique([emailAccountId])
}

model Premium {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users  User[] @relation(name: "userPremium")
  admins User[]

  pendingInvites String[]

  // lemon squeezy
  lemonSqueezyRenewsAt           DateTime?
  lemonSqueezyCustomerId         Int?
  lemonSqueezySubscriptionId     Int?
  lemonSqueezySubscriptionItemId Int?
  lemonSqueezyOrderId            Int? // lifetime purchase is an order and not a subscription
  lemonSqueezyProductId          Int?
  lemonSqueezyVariantId          Int?
  lemonLicenseKey                String?
  lemonLicenseInstanceId         String?
  lemonSubscriptionStatus        String?

  // stripe
  stripeCustomerId         String?   @unique
  stripeSubscriptionId     String?   @unique
  stripeSubscriptionItemId String?   @unique
  stripePriceId            String?
  stripeProductId          String?
  stripeSubscriptionStatus String? // The current status from Stripe (e.g., 'active', 'trialing', 'past_due', 'canceled', 'unpaid').
  stripeCancelAtPeriodEnd  Boolean? // If true, the subscription is set to cancel automatically at the end of the current billing period, rather than renew.
  stripeRenewsAt           DateTime? // Timestamp for when the current billing period ends and the subscription attempts renewal (if not canceling). Derived from `current_period_end`.
  stripeTrialEnd           DateTime? // Timestamp for when the free trial period ends (if applicable). Important for managing trial-to-paid transitions.
  stripeCanceledAt         DateTime? // Timestamp for when the subscription was definitively marked as canceled in Stripe (might be immediate or after period end). Historical data.
  stripeEndedAt            DateTime? // Timestamp for when the subscription ended permanently for any reason (cancellation, final payment failure). Historical data.

  tier PremiumTier?

  emailAccountsAccess Int?

  // unsubscribe/ai credits
  // if `unsubscribeMonth` not set to this month, set to current month
  // reset `unsubscribeCredits` each time month is changed
  unsubscribeMonth   Int? // 1-12
  unsubscribeCredits Int?
  aiMonth            Int? // 1-12
  aiCredits          Int?

  // Payment history
  payments Payment[]

  @@index([pendingInvites])
}

// not in use as it's only used for passwordless login
model VerificationToken {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Label {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  gmailLabelId String
  name         String
  description  String? // used in prompts
  enabled      Boolean  @default(true)

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([gmailLabelId, emailAccountId])
  @@unique([name, emailAccountId])
}

model Rule {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  name         String
  actions      Action[]
  enabled      Boolean  @default(true)
  automate     Boolean  @default(true) // @deprecated - No longer used. All rules are now automated. Kept for historical data only.
  runOnThreads Boolean  @default(false) // if disabled, only runs on individual emails

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  executedRules ExecutedRule[]

  // conditions: ai, group, static, category
  conditionalOperator LogicalOperator @default(AND)

  // ai conditions
  instructions String?

  // group condition
  groupId String? @unique
  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  // static condition
  // automatically apply this rule if it matches a filter. supports regex
  from    String?
  to      String?
  subject String?
  body    String?

  // category condition
  // only apply to (or do not apply to) senders in these categories
  categoryFilterType CategoryFilterType? // deprecated
  categoryFilters    Category[] // deprecated

  systemType SystemType?

  promptText String? // natural language for this rule for prompt file. prompt file is combination of these fields

  history RuleHistory[]

  @@unique([name, emailAccountId])
  @@unique([emailAccountId, systemType])
}

model Action {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  type      ActionType
  ruleId    String
  rule      Rule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  label          String? // labelName - labelId is the source of truth, and we use it when set
  labelId        String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
  subject        String?
  content        String?
  to             String?
  cc             String?
  bcc            String?
  url            String?
  folderName     String?
  folderId       String?
  delayInMinutes Int?

  @@index([ruleId])
}

model RuleHistory {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  ruleId      String
  rule        Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  version     Int
  triggerType String // "ai_update" (AI), "manual_update" (user), "ai_creation" (AI), "manual_creation" (user), "system_creation" (system), "system_update" (system)
  promptText  String? // The prompt text that generated this version

  name                String
  instructions        String?
  enabled             Boolean
  automate            Boolean
  runOnThreads        Boolean
  conditionalOperator String
  from                String?
  to                  String?
  subject             String?
  body                String?
  categoryFilterType  String? // deprecated
  systemType          String?

  actions         Json
  categoryFilters Json? // deprecated

  @@unique([ruleId, version])
  @@index([ruleId, createdAt])
}

// Rule/Action models represent the rules and actions that the AI can take.
// ExecutedRule/ExecutedAction models represent the rules/actions that have been planned or executed by the AI.
model ExecutedRule {
  id            String             @id @default(cuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  threadId      String
  messageId     String
  status        ExecutedRuleStatus
  automated     Boolean
  reason        String?
  matchMetadata Json? // Stores structured match information (e.g., learned patterns, match types)

  // may be null if the rule was deleted
  ruleId String?
  rule   Rule?   @relation(fields: [ruleId], references: [id])

  // storing user here in case rule was deleted
  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  actionItems      ExecutedAction[]
  scheduledActions ScheduledAction[]

  @@index([emailAccountId, threadId, messageId, ruleId])
  @@index([emailAccountId, messageId])
  @@index([emailAccountId, status, createdAt])
}

model ExecutedAction {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  type           ActionType
  executedRuleId String
  executedRule   ExecutedRule @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)

  // optional extra fields to be used with the action
  label      String?
  labelId    String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
  subject    String?
  content    String?
  to         String?
  cc         String?
  bcc        String?
  url        String?
  folderName String?
  folderId   String?

  // additional fields as a result of the action
  draftId         String? // Gmail draft ID created by DRAFT_EMAIL action
  wasDraftSent    Boolean? // Tracks if the corresponding draft was sent (true) or ignored/superseded (false)
  draftSendLog    DraftSendLog? // Will exist if the draft was sent
  digestItems     DigestItem[] // Relation to digest items created by this action
  scheduledAction ScheduledAction? // Reverse relation for delayed actions

  @@index([executedRuleId])
}

model ScheduledAction {
  id               String                @id @default(cuid())
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  executedRuleId   String
  actionType       ActionType
  messageId        String
  threadId         String
  scheduledFor     DateTime
  emailAccountId   String
  status           ScheduledActionStatus @default(PENDING)
  schedulingStatus SchedulingStatus      @default(PENDING)

  label       String?
  labelId     String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
  subject     String?
  content     String?
  to          String?
  cc          String?
  bcc         String?
  url         String?
  folderName  String?
  folderId    String?
  scheduledId String?

  executedAt       DateTime?
  executedActionId String?   @unique

  executedRule   ExecutedRule    @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
  executedAction ExecutedAction? @relation(fields: [executedActionId], references: [id], onDelete: Cascade)
  emailAccount   EmailAccount    @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@index([executedRuleId])
  @@index([status, scheduledFor])
  @@index([emailAccountId, messageId])
}

// Notes:
// In the past groups stood on their own. Now they are attached to a rule.
// A group without a rule does not do anything anymore. I may delete all detached groups in the future, and then make rule required
// "Prompt" is no longer in use. It was used to generate the group, but now it's based on the rule the group is attached to.
// "Name" is no longer in use although still required.
// If we really wanted we could remove Group and just have a relation between Rule and GroupItem, but leaving as is for now.
model Group {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  prompt    String?

  items GroupItem[]
  rule  Rule?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([name, emailAccountId])
}

model GroupItem {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  groupId   String?
  group     Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  type      GroupItemType
  value     String // eg "@gmail.com", "matt@gmail.com", "Receipt from"
  exclude   Boolean       @default(false) // Whether this pattern should be excluded rather than included

  @@unique([groupId, type, value])
}

model Category {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  name        String
  description String?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  emailSenders Newsletter[]
  rules        Rule[]

  @@unique([name, emailAccountId])
}

// Represents a sender (`email`) that a user can unsubscribe from,
// or that our AI can mark as a cold email.
// `Newsletter` is a bad name for this. Will rename this model in the future.
model Newsletter {
  id        String            @id @default(cuid())
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  email     String
  status    NewsletterStatus?

  // For learned patterns for rules
  patternAnalyzed Boolean   @default(false)
  lastAnalyzedAt  DateTime?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id])

  @@unique([email, emailAccountId])
  @@index([emailAccountId, status])
  @@index([categoryId])
}

model ColdEmail {
  id        String           @id @default(cuid())
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  fromEmail String
  messageId String?
  threadId  String?
  status    ColdEmailStatus?
  reason    String?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  digestItems DigestItem[]

  @@unique([emailAccountId, fromEmail])
  @@index([emailAccountId, status])
  @@index([emailAccountId, createdAt])
}

model EmailMessage {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  threadId        String
  messageId       String
  date            DateTime // date of the email
  from            String
  fromName        String? // sender's display name
  fromDomain      String
  to              String
  unsubscribeLink String?
  read            Boolean
  sent            Boolean
  draft           Boolean
  inbox           Boolean

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, threadId])
  @@index([emailAccountId, date])
  @@index([emailAccountId, from])
}

model ThreadTracker {
  id        String            @id @default(cuid())
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  sentAt    DateTime
  threadId  String
  messageId String
  resolved  Boolean           @default(false)
  type      ThreadTrackerType

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, threadId, messageId])
  @@index([emailAccountId, resolved])
  @@index([emailAccountId, resolved, sentAt, type])
  @@index([emailAccountId, type, resolved, sentAt])
}

model CleanupJob {
  id               String      @id @default(cuid())
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  action           CleanAction @default(ARCHIVE)
  daysOld          Int         @default(7)
  instructions     String?
  skipReply        Boolean?
  skipStarred      Boolean?
  skipCalendar     Boolean?
  skipReceipt      Boolean?
  skipAttachment   Boolean?
  skipConversation Boolean?

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  threads CleanupThread[]

  @@index([emailAccountId])
}

model CleanupThread {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  threadId  String
  archived  Boolean // this can also mean "mark as read". depends on CleanupJob.action
  jobId     String
  job       CleanupJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@index([jobId])
}

model Knowledge {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@unique([emailAccountId, title])
}

model ApiKey {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  hashedKey String   @unique
  isActive  Boolean  @default(true)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
}

model EmailToken {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  token     String   @unique
  expiresAt DateTime
  // action    EmailTokenAction @default(UNSUBSCRIBE)

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@index([emailAccountId])
}

model Payment {
  id        String   @id @default(cuid())
  createdAt DateTime // from processor
  updatedAt DateTime // from processor

  // Relation to Premium
  premiumId String?
  premium   Premium? @relation(fields: [premiumId], references: [id], onDelete: SetNull)

  @@index([premiumId])

  // Payment processor information
  processorType           ProcessorType @default(LEMON_SQUEEZY)
  processorId             String?       @unique // External payment ID from Stripe/Lemon Squeezy
  processorSubscriptionId String? // External subscription ID
  processorCustomerId     String? // External customer ID

  // Core payment information
  amount       Int // Total amount in cents
  currency     String // 3-letter currency code: USD, EUR, etc.
  status       String // paid, failed, refunded, etc.
  tax          Int
  taxInclusive Boolean

  // Refund information
  refunded       Boolean   @default(false)
  refundedAt     DateTime?
  refundedAmount Int? // in cents

  // Metadata
  billingReason String? // initial, renewal, update, etc.
}

model DraftSendLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  executedActionId String         @unique
  executedAction   ExecutedAction @relation(fields: [executedActionId], references: [id], onDelete: Cascade)

  sentMessageId   String
  similarityScore Float // Similarity score (0.0 to 1.0) between original draft and sent message

  @@index([executedActionId])
}

model Chat {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages       ChatMessage[]
  emailAccountId String
  emailAccount   EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  @@index([emailAccountId])
}

model ChatMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  role  String
  parts Json
  // attachments Json?

  chatId String
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId])
}

model CalendarConnection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  provider     String // "google" or "microsoft"
  email        String // Google account email (e.g., "elie@gmail.com")
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  isConnected  Boolean   @default(true)

  emailAccountId String
  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  calendars Calendar[]

  @@unique([emailAccountId, provider, email]) // Allow multiple Google accounts per user
}

model Calendar {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  calendarId  String // External calendar ID from provider
  name        String
  description String?
  primary     Boolean @default(false)
  isEnabled   Boolean @default(true)
  timezone    String?

  connectionId String
  connection   CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@unique([connectionId, calendarId])
}

model Referral {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // The user who made the referral (referrer)
  referrerUserId String
  referrerUser   User   @relation(name: "ReferrerUser", fields: [referrerUserId], references: [id], onDelete: Cascade)

  // The user who was referred
  referredUserId String @unique // Each user can only be referred once
  referredUser   User   @relation(name: "ReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)

  // The referral code used (stored as string)
  referralCodeUsed String

  // Status tracking
  status ReferralStatus @default(PENDING)

  // Reward tracking - using Stripe balance transactions
  rewardGrantedAt            DateTime?
  stripeBalanceTransactionId String? // Store Stripe txn ID for reference
  rewardAmount               Int? // Amount in cents (e.g., 2000 for $20)

  @@index([referrerUserId])
  @@index([status])
}

model McpIntegration {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String @unique // Lookup key to MCP_INTEGRATIONS config

  // OAuth registration metadata (captured during dynamic registration)
  // These represent what the credentials below were registered for
  registeredServerUrl        String? // Server URL credentials are registered with
  registeredAuthorizationUrl String? // OAuth authorization endpoint used
  registeredTokenUrl         String? // OAuth token endpoint used

  // OAuth client credentials (from dynamic registration - shared across all users)
  oauthClientId     String?
  oauthClientSecret String?

  connections McpConnection[]
}

model McpConnection {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name     String
  isActive Boolean @default(true)

  // Encrypted credentials
  accessToken  String?
  refreshToken String?
  apiKey       String?
  expiresAt    DateTime?

  integrationId  String
  integration    McpIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  emailAccountId String?
  emailAccount   EmailAccount?  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  tools          McpTool[]

  @@unique([emailAccountId, integrationId])
}

model McpTool {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String
  description String?
  schema      Json?
  isEnabled   Boolean @default(true)

  connectionId String
  connection   McpConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@unique([connectionId, name])
}

enum ActionType {
  ARCHIVE
  LABEL
  REPLY
  SEND_EMAIL
  FORWARD
  DRAFT_EMAIL
  MARK_SPAM
  CALL_WEBHOOK
  MARK_READ
  // TRACK_THREAD // @deprecated - No longer used. We rely on rule SystemType instead to run this.
  DIGEST
  MOVE_FOLDER
  // SUMMARIZE
  // SNOOZE
  // ADD_TO_DO
  // INTEGRATION // for example, add to Notion
}

enum Frequency {
  NEVER
  DAILY
  WEEKLY
  // MONTHLY
  // ANNUALLY
}

enum NewsletterStatus {
  APPROVED
  UNSUBSCRIBED
  AUTO_ARCHIVED
}

enum ColdEmailStatus {
  AI_LABELED_COLD
  USER_REJECTED_COLD
}

// @deprecated - No longer used
enum ColdEmailSetting {
  DISABLED
  LIST
  LABEL
  ARCHIVE_AND_LABEL
  ARCHIVE_AND_READ_AND_LABEL
}

enum PremiumTier {
  BASIC_MONTHLY
  BASIC_ANNUALLY
  PRO_MONTHLY
  PRO_ANNUALLY
  BUSINESS_MONTHLY
  BUSINESS_ANNUALLY
  BUSINESS_PLUS_MONTHLY
  BUSINESS_PLUS_ANNUALLY
  COPILOT_MONTHLY
  LIFETIME
}

enum ExecutedRuleStatus {
  APPLIED
  APPLYING
  REJECTED // @deprecated - No longer created. Kept for historical data only.
  PENDING // @deprecated - No longer created. Kept for historical data only.
  SKIPPED
  ERROR
}

enum GroupItemType {
  FROM
  SUBJECT
  BODY
}

enum CategoryFilterType {
  INCLUDE
  EXCLUDE
}

enum LogicalOperator {
  AND
  OR
}

enum ThreadTrackerType {
  AWAITING // We're waiting for their reply
  NEEDS_REPLY // We need to reply to this
  NEEDS_ACTION // We need to do something else
}

enum ProcessorType {
  LEMON_SQUEEZY
  STRIPE
}

enum CleanAction {
  ARCHIVE
  MARK_READ
}

enum SystemType {
  // conversation trackers
  TO_REPLY
  FYI
  AWAITING_REPLY
  ACTIONED
  // cold email blocker
  COLD_EMAIL
  // other labels
  NEWSLETTER
  MARKETING
  CALENDAR
  RECEIPT
  NOTIFICATION
}

enum ReferralStatus {
  PENDING // Referral created, waiting for trial completion
  COMPLETED // Referral completed and reward granted
}

enum DigestStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
}

enum ScheduledActionStatus {
  PENDING
  EXECUTING
  COMPLETED
  FAILED
  CANCELLED
}

enum SchedulingStatus {
  PENDING
  SCHEDULED
  FAILED
}
