import { type gmail_v1 } from "googleapis";
import uniq from "lodash/uniq";
import { Function } from "ai";
import { UserAIFields } from "@/utils/llms/types";
import { RuleWithActions } from "@/utils/types";
import {
  ACTION_PROPERTIES,
  ActionItem,
  ActionProperty,
  actionFunctionDefs,
  runActionFunction,
} from "@/utils/ai/actions";
import prisma from "@/utils/prisma";
import { Rule, User } from "@prisma/client";
import { ActBody, ActBodyWithHtml } from "@/app/api/ai/act/validation";
import { getOrCreateInboxZeroLabel } from "@/utils/label";
import { labelThread } from "@/utils/gmail/label";
import { AI_GENERATED_FIELD_VALUE } from "@/utils/config";
import { emailToContent } from "@/utils/mail";
import { ExecutedRuleStatus } from "@prisma/client";
import {
  getActionItemsFromAiArgsResponse,
  getArgsAiResponse,
} from "@/app/api/ai/act/ai-choose-args";
import { REQUIRES_MORE_INFO } from "@/app/api/ai/act/consts";
import { getAiResponse } from "@/app/api/ai/act/ai-choose-rule";

export type ActResponse = Awaited<ReturnType<typeof planOrExecuteAct>>;

// This finds the properties that must be generated by the AI.
// NOTE: if two actions require the same field, the AI will generate the same value for both.
// For example, if two actions require the "content" field, the AI will generate the same content for both.
// We probably want to improve this in the future. So that action1.content and action2.content are different.
export function getFunctionsFromRules(options: { rules: RuleWithActions[] }) {
  const rulesWithProperties = options.rules.map((rule, i) => {
    const toAiGenerateValues: ActionProperty[] = [];

    rule.actions.forEach((action) => {
      ACTION_PROPERTIES.forEach((property) => {
        if (action[property] === AI_GENERATED_FIELD_VALUE) {
          toAiGenerateValues.push(property);
        }
      });
    });

    const shouldAiGenerateArgs = toAiGenerateValues.length > 0;

    return {
      rule,
      shouldAiGenerateArgs,
      name: `rule_${i + 1}`,
      description: rule.instructions,
      parameters: {
        type: "object",
        properties: rule.actions.reduce(
          (properties, action) => {
            const actionProperties = {
              ...actionFunctionDefs[action.type].parameters.properties,
            };

            return { ...properties, ...actionProperties };
          },
          {} as {
            [key: string]: {
              type: string;
              description: string;
            };
          },
        ),
        required: uniq(
          rule.actions.flatMap((action) => {
            return actionFunctionDefs[action.type].parameters.required;
          }),
        ),
      },
    };
  });

  rulesWithProperties.push({
    name: REQUIRES_MORE_INFO,
    description: "Request more information to handle the email.",
    parameters: {
      type: "object",
      properties: {},
      required: [],
    },
    shouldAiGenerateArgs: false,
    rule: {} as any,
  });

  const functions: Function[] = rulesWithProperties.map((r) => ({
    name: r.name,
    description: r.description,
    parameters: r.parameters,
  }));

  return { functions, rulesWithProperties };
}

export async function planAct(options: {
  email: ActBody["email"] & { content: string; snippet: string };
  rules: RuleWithActions[];
  user: Pick<User, "email" | "about"> & UserAIFields;
}): Promise<
  | {
      rule: Rule;
      actionItems: ActionItem[];
      reason?: string;
    }
  | { rule?: undefined; actionItems?: undefined; reason?: string }
> {
  const { email, rules, user } = options;
  const { functions, rulesWithProperties } = getFunctionsFromRules({ rules });

  const aiResponse = await getAiResponse({
    email,
    functions,
    user,
  });

  const ruleNumber = aiResponse ? aiResponse.rule - 1 : undefined;
  if (typeof ruleNumber !== "number") {
    console.warn("No rule selected");
    return { reason: aiResponse?.reason };
  }

  const selectedRule = rulesWithProperties[ruleNumber];
  console.log("selectedRule", selectedRule.name);

  if (selectedRule.name === REQUIRES_MORE_INFO)
    return { reason: aiResponse?.reason };

  // TODO may want to pass full email content to this function so it has maximum context to act on
  const aiArgsResponse = selectedRule.shouldAiGenerateArgs
    ? await getArgsAiResponse({
        ...options,
        email,
        selectedFunction: selectedRule,
      })
    : undefined;

  const actionItems = getActionItemsFromAiArgsResponse(
    aiArgsResponse,
    selectedRule.rule.actions,
  );

  return {
    rule: selectedRule.rule,
    actionItems,
    reason: aiResponse?.reason,
  };
}

export async function executeAct(options: {
  gmail: gmail_v1.Gmail;
  actionItems: ActionItem[];
  email: ActBodyWithHtml["email"];
  userEmail: string;
  executedRuleId: string;
}) {
  const { gmail, email, actionItems, userEmail, executedRuleId } = options;

  console.log("Executing act:", JSON.stringify(actionItems, null, 2));

  async function labelActed() {
    const label = await getOrCreateInboxZeroLabel({
      gmail,
      email: userEmail,
      labelKey: "acted",
    });

    if (!label) return;

    return labelThread({
      gmail,
      labelId: label.id,
      threadId: email.threadId,
    });
  }

  await Promise.allSettled([
    ...actionItems.map(async (action) => {
      return runActionFunction(gmail, email, action, userEmail);
    }),
    prisma.executedRule.update({
      where: { id: executedRuleId },
      data: { status: ExecutedRuleStatus.APPLIED },
    }),
    labelActed(),
  ]);
}

type PlanOrExecuteActOptions = {
  gmail: gmail_v1.Gmail;
  email: ActBodyWithHtml["email"];
  rules: RuleWithActions[];
  allowExecute: boolean;
  forceExecute?: boolean;
  automated: boolean;
  user: Pick<User, "id" | "email" | "about"> & UserAIFields;
};

export async function planOrExecuteAct(options: PlanOrExecuteActOptions) {
  const { rules, email, user, automated } = options;

  if (!rules.length) return;

  const content = emailToContent(email);

  const plannedAct = await planAct({
    ...options,
    email: {
      ...email,
      content: content || "",
      snippet: email.snippet || "",
    },
  });

  console.log("Planned act:", plannedAct.rule?.name, plannedAct.actionItems);

  // no rule to apply to this thread
  if (!plannedAct.rule) {
    await prisma.executedRule.upsert({
      where: {
        unique_user_thread_message: {
          userId: user.id,
          threadId: email.threadId,
          messageId: email.messageId,
        },
      },
      create: {
        threadId: email.threadId,
        messageId: email.messageId,
        automated,
        reason: plannedAct.reason,
        status: ExecutedRuleStatus.SKIPPED,
        user: { connect: { id: user.id } },
      },
      update: {
        threadId: email.threadId,
        messageId: email.messageId,
        automated,
        reason: plannedAct.reason,
        status: ExecutedRuleStatus.SKIPPED,
        user: { connect: { id: user.id } },
      },
    });

    return plannedAct;
  }

  await excuteRuleActions(options, plannedAct);

  return plannedAct;
}

export async function excuteRuleActions(
  options: Pick<
    PlanOrExecuteActOptions,
    "email" | "user" | "allowExecute" | "forceExecute" | "gmail"
  >,
  plannedAct: Awaited<ReturnType<typeof planAct>>,
) {
  const { email, user, allowExecute, forceExecute } = options;

  if (!plannedAct.rule) return;

  const data = {
    actionItems: { createMany: { data: plannedAct.actionItems || [] } },
    messageId: email.messageId,
    threadId: email.threadId,
    automated: plannedAct.rule.automate,
    status: ExecutedRuleStatus.PENDING,
    reason: plannedAct.reason,
    rule: plannedAct.rule?.id
      ? { connect: { id: plannedAct.rule.id } }
      : undefined,
    user: { connect: { id: user.id } },
  };

  const executedRule = await prisma.executedRule.upsert({
    where: {
      unique_user_thread_message: {
        userId: user.id,
        threadId: email.threadId,
        messageId: email.messageId,
      },
    },
    create: data,
    update: data,
  });

  const shouldExecute =
    allowExecute && (plannedAct.rule.automate || forceExecute);

  if (shouldExecute) {
    await executeAct({
      gmail: options.gmail,
      actionItems: plannedAct.actionItems,
      email,
      userEmail: user.email || "",
      executedRuleId: executedRule.id,
    });
  }
}
