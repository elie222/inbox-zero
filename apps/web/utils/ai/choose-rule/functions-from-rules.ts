import { Function } from "ai";
import pickBy from "lodash/pickBy";
import { actionFunctionDefs } from "@/utils/ai/actions";
import { REQUIRES_MORE_INFO } from "@/utils/ai/choose-rule/consts";
import { AI_GENERATED_FIELD_VALUE } from "@/utils/config";
import { isDefined, RuleWithActions } from "@/utils/types";

type FunctionWithDescription = Function & { description: string };

// This finds the properties that must be generated by the AI.
// NOTE: if two actions with the same type require ai args generation, the AI will only add one of the actions to the function.
// For example, if there are two "Draft email" actions, the AI will only add one of them to the function.
// TODO should be able to fix this with draft_email, draft_email_2, etc.
export function getFunctionsFromRules({ rules }: { rules: RuleWithActions[] }) {
  const rulesWithFunctions = rules.map((rule, i) => {
    // find the properties that must be generated by the AI
    const functionForArgsProperties = Object.fromEntries(
      rule.actions
        .map((action) => {
          // only include properties that must be generated by the AI
          const properties = pickBy(
            actionFunctionDefs[action.type].parameters.properties,
            (_, key) => (action as any)[key] === AI_GENERATED_FIELD_VALUE,
          );
          const propertyKeys = Object.keys(properties);

          if (propertyKeys.length === 0) return;

          return [
            action.type,
            {
              type: "object",
              properties,
              required: actionFunctionDefs[
                action.type
              ].parameters.required.filter((requiredKey) =>
                propertyKeys.includes(requiredKey),
              ),
            },
          ];
        })
        .filter(isDefined),
    );

    return {
      rule,
      function: {
        name: `rule_${i + 1}`,
        description: rule.instructions,
        parameters: {},
      } as FunctionWithDescription,
      shouldAiGenerateArgs: Object.keys(functionForArgsProperties).length > 0,
      functionForArgs: {
        name: "handle_email",
        description: "Handle the email.",
        parameters: {
          type: "object",
          properties: functionForArgsProperties,
          required: rule.actions
            .map((action) => action.type)
            // filter out properties that do not exist in the functionForArgsProperties
            .filter((t) => functionForArgsProperties[t]),
        },
      } as FunctionWithDescription,
    };
  });

  rulesWithFunctions.push({
    rule: {} as any,
    shouldAiGenerateArgs: false,
    function: {
      name: REQUIRES_MORE_INFO,
      description: "Request more information to handle the email.",
      parameters: {
        type: "object",
        properties: {},
        required: [],
      },
    } as FunctionWithDescription,
    functionForArgs: {} as FunctionWithDescription,
  });

  return rulesWithFunctions;
}
